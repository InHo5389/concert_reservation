# 콘서트 예약 서비스
## 요구 사항
아래 5가지 API 를 구현합니다.
- 유저 토큰 발급 API
- 예약 가능 날짜 / 좌석 API
- 좌석 예약 요청 API
- 잔액 충전 / 조회 API
- 결제 API
</br>
각 기능 및 제약사항에 대해 단위 테스트를 반드시 하나 이상 작성하도록 합니다.
다수의 인스턴스로 어플리케이션이 동작하더라도 기능에 문제가 없도록 작성하도록 합니다.
동시성 이슈를 고려하여 구현합니다.
대기열 개념을 고려해 구현합니다.
<details>
  <summary>동시성 문제와 유즈케이스 분석</summary>

# 동시성 문제와 유즈케이스 분석

- 콘서트 예약 서비스에서 동시성 문제에 대한 분석 자료를 정리하였습니다.

## 목차

- [Use Case #1: 좌석 예약](#use-case-1-좌석-예약)
- [Use Case #2: 포인트 충전](#use-case-2-포인트-충전)

## Use Case #1: 좌석 예약

콘서트 예약 서비스에서 좌석을 예약하기 위한 유즈케이스입니다.

### 1. 요구사항

- 예약을 통해 좌석을 임시로 할당 받습니다.
- 좌석의 임시 할당은 5분동안 유지됩니다.
- 임시 할당은 결제가 완료되어야 예약 처리됩니다.
- 대기열을 통과한 사용자만 이용할 수 있습니다.

### 2. 동시성 문제

> **Note**  
> 대기열이 있다면 동시성 이슈를 다룰 필요가 없지 않나요?
>
> 그렇지 않습니다. 서버가 받아들일 수 있는 사용자의 수가 1명이 아닌 10명일 수 있고, 100명일 수 있습니다. 또한, 사용자는 대기열이 통과된 순간 한 번에 예약하려고 하기 때문에 동시성 이슈가 발생할 여지가 있습니다.

사용자는 대기열 순번이 돌아왔을 때 예약을 진행할 수 있습니다.

많약 대량의 인원이 예약을 진행하려고 해도 대기열 시스템을 통해 정해진 인원만 예약을 받을 수 있는 시스템입니다.

임자 가능한 인원이 한 명일 경우 동시성 이슈가 발생하지 않습니다. 하지만, 부동 한 명만 받지는 않죠. 임장 허용 인원이 10명일 수도 있고 1,000명, 10,000명 일 수도 있습니다.

이러한 상황은 대규모의 동시성을 제어해야 하는 상황은 아닙니다. 그럼다고 해서 동시성 이슈를 배제할 수는 없습니다.

예를 들어 한 번에 입장 가능한 인원이 10명이라고 칩시다. 순번이 돌아오는 시점 즉, 10명이 한 번에 입장하여 빠르게 예약을 진행할 수 있습니다. (한국인 특성상 어떻게든 줄은 자리를 차지하려고 전쟁이 벌어지겠죠)

### 3. 해결 방법

이러한 상황에서는 낙관적 락(optimistic lock)을 이용해 문제를 해결하는 것이 적절하다고 판단됩니다.

비관적 락이 아닌 낙관적 락을 사용하는 이유는 다음과 같습니다.

> **Note**  
> 낙관적 락은 데이터베이스에 대한 변경이 드물게 발생하고, 충돌 가능성이 낮은 환경에서 유용합니다. 왜냐하면, 이 방식은 충돌이 발생할 것이라고 '낙관적'으로 가정하고, 실제로 충돌이 발생했을 때만 대응하기 때문입니다.

#### [3.1] Optimistic Lock을 사용하는 이유

1. 예약 유즈케이스는 대기열을 통해 대규모 요청을 일부 막아줍니다. 때문에 충돌 가능성이 비교적 낮은 편입니다.
2. 낙관적은 충돌이 발생한 시점에 대응할 수 있기 때문에 성능 저하를 최소화하고 동시성을 높이는데 유리합니다. 따라서 충돌 가능성이 비교적 낮은 예약 유즈케이스에 적합하다고 판단됩니다.
3. 비관적과 다르게 낙관락은 충돌이 발생하면 선처한 요청을 제외한 나머지 요청은 자연스럽게 배제됩니다. 이러한 방식은 예약 유즈케이스에 (좌석을 예약하면 됨) 적합하다고 생각합니다.

즉, Optimistic Lock 의 단점인 업데이트가 실패했을 때 재시도 로직을 직접 작성해야 되는 것인데 콘서트 좌석 예약은 재시도로직을 작성할 필요없이 예외 메세지를 보내고 다른 예약들을 실패처리 하면 된다고 생각했습니다.

#### [3.2] 동시성 테스트 진행
낙관적 락을 이용해 동시성을 제어할 수 있는지 테스트 코드를 작성하였습니다.

아래와 같이 속도도 우세한 걸 확인했습니다.
- 쓰레드 1000개 동시성 테스트 결과 - 낙관적 락 (2579ms)
- 쓰레드 1000개 동시성 테스트 결과 - 비관적 락 (5762ms)

## Use Case #2: 포인트 충전

콘서트 예약 서비스에서 전액을 충전하기 위한 유즈케이스입니다.

### 1. 동시성 문제

포인트 충전의 경우, 포인트를 충전하려는 사용자를 조회한 후 현재 잔액에서 증가하려는 금액을 더하는 방식으로 구현되어 있습니다.

**포인트를 충전하는 방식**

1. 사용자의 현재 잔액을 조회한다. (`select balance from user where id = ?`)
2. 조회한 현재 잔액에서 충전 금액을 더한 후 업데이트한다. (`update user set balance += ? where id = ?`)

때문에 한 사용자가 여러 건의 포인트 충전 요청한다면 동시성 이슈가 발생하게 됩니다.

> [!IMPORTANT]  
> 쿼리는 각각 사용자 잔액을 10,000 포인트 증가시키려고 합니다. 두 번의 요청이 들어와 최종 포인트 잔액은 20,000 포인트가 되어야 하지만 결과적으로는 10,000 포인트가 되었습니다. 이렇게 된 이유는 조회 시점에서 포인트 잔액을 가져올 때, 업데이트되지 않은 결과를 가져오기 때문입니다. 즉, DB 테이블의 사용자 row는 한 쪽 구역에서 두 트랜잭션의 경쟁 조건이 발생하게 됩니다.

### 2. 해결 방법

이 문제는 비관적 락을 사용하여 해결하는 것이 더 적절하다고 판단됩니다. 그 이유는 다음과 같습니다:

1. **데이터 정합성이 매우 중요다고 판단**
  - 포인트/금액과 관련된 처리는 절대로 데이터 손실이 있어서는 안 됩니다.
  - 낙관적 락의 경우 충돌 시 재시도 로직이 필요한데, 금액 처리에서의 재시도는 위험할 수 있습니다.

2. **높은 충돌 가능성**
  - 동일 사용자의 포인트 충전은 짧은 시간 내에 여러 번 발생할 가능성이 있습니다.
  - 특히 자동 충전이나 정기 충전 같은 기능이 있다면 충돌 가능성이 더욱 높아집니다.

3. **트랜잭션 격리가 필수적인 상황**
  - 포인트 충전은 읽기-쓰기가 동시에 일어나는 작업입니다.
  - 비관적 락을 통해 다른 트랜잭션의 접근을 원천적으로 차단하는 것이 안전합니다.

4. **성능보다 정확성이 우선**
  - 포인트 충전에서는 약간의 성능 저하가 있더라도 정확한 처리가 더 중요합니다.
  - 비관적 락의 성능 오버헤드는 이 경우 감수할 수 있는 수준입니다.

#### [2.1] 동시성 테스트 진행

아래와 같이 속도가 비슷한걸 확인하였습니다.
- 쓰레드 1000개 동시성 테스트 결과 - 낙관적 락 (4613ms)
- 쓰레드 1000개 동시성 테스트 결과 - 비관적 락 (4449ms)

</details>

<details>
  <summary>Entity-Relationship Diagram</summary>
  ![Entity-Relationship Diagram](https://github.com/InHo5389/concert_reservation/assets/80667642/da8c2198-fc99-4678-9b2a-94aa17854fe8)
</details>


<details>
  <summary>Sequence Diagram</summary>
  
  ![Sequence Diagram 1](https://github.com/InHo5389/concert_reservation/assets/80667642/4df13b5c-f3db-421f-981f-68ce89bd36b6)
  
  ![Sequence Diagram 2](https://github.com/InHo5389/concert_reservation/assets/80667642/f577606b-933f-42e0-b5e6-6d0a8ba045de)
</details>

<details>
  <summary>Milestone</summary>
  
  ![Milestone](https://github.com/InHo5389/concert_reservation/assets/80667642/c8bb3913-25bb-44ae-aa02-30c0bf87f31b)
</details>
